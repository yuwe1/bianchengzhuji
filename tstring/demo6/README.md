##### 人生就是一场游戏，我们不停的打怪通关，有的时候这个怪物是自己。————陌无崖

### 题目要求
字符串转换成整数，并成功解决溢出的情况 

### 分析
对于Go语言首先我们需要了解在Go中，不同的数据类型取值范围不同，在本例中我们以int32为例，int32的取值范围为 (-2147483648 到 2147483647)

本题实际考察的就是溢出的问题，即如何成功的解决溢出，对于字符串转换成整数我们可以逐个字符进行分析，我们用字符串“456”分析步骤：
1. 当扫描到字符为4的时候，因为这是第一位，得到整数4
2. 当扫描到字符5的时候，这时因为是第二位，用4 x 10 + 5 可以得到45
3. 当扫描到最后一位的时候，使用45 x 10 + 6

通过以上分析，我们很容易的可以写出代码如下:
```go
func strToIntOne(str string) int32 {
	if len(str) == 0 {
		return 0
	}
	// 转换成字节数组
	r := []rune(str)
	//代表最终的结果，刚开始为0
	n := int32(0)
	for i := 0; i < len(r); i++ {
		// 表示当前的数字
		c := int32(r[i] - '0')
		n = n*10 + c
	}
	return n
}
```

当然为了简单我们省去了判断正负号，省去了判断字符串是否为全是数字组成的字符串，但是对于溢出我们并没有解决，现在我们开始 分析如何解决溢出

对与溢出分析，按照习惯的逻辑，我们通常有两个方法：
**第一个方法**
两个整数比较，我们会先比较长度，长度相同的情况下我们便开始逐个的将数字一一对应的比较，这样的方法，转成代码我们为了完成一对一的比较，就必须将两个整数都转成成字符串，然后进行遍历比较。
**第二个方法**
举例“2147483648”这个字符串
对于这个字符串，它是在2147483640 +  8 > 2147483640 +  7 = Max
举例“2147483698”这个字符串
对于这个字符串，它是在2147483690 +  8 > 2147483690 +  (-43) = Max
因此我们可以得出结论，对于任何大于max都有如下等式
```go
//n 为待求的整数,c为字符串的最后一个字符
max - n * 10 < c
```
完整代码如下：
```go
func strToIntTwo(str string) int32 {
	if len(str) == 0 {
		return 0
	}
	r := []rune(str)
	n := int32(0)
	// fmt.Println(math.MaxInt32)
	// fmt.Println(math.MinInt32)
	Max_int := int32(1<<31 - 1) //math.MaxInt32
	Min_int := int32(-1 << 31)  //math.MinInt32
	// fmt.Println(Max_int)
	// fmt.Println(Min_int)
	if str[0] == '-' {
		for i := 1; i < len(r); i++ {
			c := int32(r[i] - '0')
			// 判断是否溢出
			if c-1 > (Max_int - n*10) {
				n = Min_int
				break
			}
			n = n*10 + c
		}
	} else {
		for i := 0; i < len(r); i++ {
			c := int32(r[i] - '0')
			// 判断是否溢出
			if c > (Max_int - n*10) {
				fmt.Println(c)
				fmt.Println(Max_int - n*10)
				n = Max_int
				break
			}
			n = n*10 + c
		}
	}

	return n
}
```